// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'importance.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$Importance {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() low,
    required TResult Function() basic,
    required TResult Function() important,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? low,
    TResult? Function()? basic,
    TResult? Function()? important,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? low,
    TResult Function()? basic,
    TResult Function()? important,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LowImportance value) low,
    required TResult Function(BasicImportance value) basic,
    required TResult Function(ImportantImportance value) important,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LowImportance value)? low,
    TResult? Function(BasicImportance value)? basic,
    TResult? Function(ImportantImportance value)? important,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LowImportance value)? low,
    TResult Function(BasicImportance value)? basic,
    TResult Function(ImportantImportance value)? important,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ImportanceCopyWith<$Res> {
  factory $ImportanceCopyWith(
          Importance value, $Res Function(Importance) then) =
      _$ImportanceCopyWithImpl<$Res, Importance>;
}

/// @nodoc
class _$ImportanceCopyWithImpl<$Res, $Val extends Importance>
    implements $ImportanceCopyWith<$Res> {
  _$ImportanceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LowImportanceImplCopyWith<$Res> {
  factory _$$LowImportanceImplCopyWith(
          _$LowImportanceImpl value, $Res Function(_$LowImportanceImpl) then) =
      __$$LowImportanceImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LowImportanceImplCopyWithImpl<$Res>
    extends _$ImportanceCopyWithImpl<$Res, _$LowImportanceImpl>
    implements _$$LowImportanceImplCopyWith<$Res> {
  __$$LowImportanceImplCopyWithImpl(
      _$LowImportanceImpl _value, $Res Function(_$LowImportanceImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LowImportanceImpl implements LowImportance {
  const _$LowImportanceImpl();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LowImportanceImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() low,
    required TResult Function() basic,
    required TResult Function() important,
  }) {
    return low();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? low,
    TResult? Function()? basic,
    TResult? Function()? important,
  }) {
    return low?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? low,
    TResult Function()? basic,
    TResult Function()? important,
    required TResult orElse(),
  }) {
    if (low != null) {
      return low();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LowImportance value) low,
    required TResult Function(BasicImportance value) basic,
    required TResult Function(ImportantImportance value) important,
  }) {
    return low(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LowImportance value)? low,
    TResult? Function(BasicImportance value)? basic,
    TResult? Function(ImportantImportance value)? important,
  }) {
    return low?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LowImportance value)? low,
    TResult Function(BasicImportance value)? basic,
    TResult Function(ImportantImportance value)? important,
    required TResult orElse(),
  }) {
    if (low != null) {
      return low(this);
    }
    return orElse();
  }
}

abstract class LowImportance implements Importance {
  const factory LowImportance() = _$LowImportanceImpl;
}

/// @nodoc
abstract class _$$BasicImportanceImplCopyWith<$Res> {
  factory _$$BasicImportanceImplCopyWith(_$BasicImportanceImpl value,
          $Res Function(_$BasicImportanceImpl) then) =
      __$$BasicImportanceImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BasicImportanceImplCopyWithImpl<$Res>
    extends _$ImportanceCopyWithImpl<$Res, _$BasicImportanceImpl>
    implements _$$BasicImportanceImplCopyWith<$Res> {
  __$$BasicImportanceImplCopyWithImpl(
      _$BasicImportanceImpl _value, $Res Function(_$BasicImportanceImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BasicImportanceImpl implements BasicImportance {
  const _$BasicImportanceImpl();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$BasicImportanceImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() low,
    required TResult Function() basic,
    required TResult Function() important,
  }) {
    return basic();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? low,
    TResult? Function()? basic,
    TResult? Function()? important,
  }) {
    return basic?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? low,
    TResult Function()? basic,
    TResult Function()? important,
    required TResult orElse(),
  }) {
    if (basic != null) {
      return basic();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LowImportance value) low,
    required TResult Function(BasicImportance value) basic,
    required TResult Function(ImportantImportance value) important,
  }) {
    return basic(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LowImportance value)? low,
    TResult? Function(BasicImportance value)? basic,
    TResult? Function(ImportantImportance value)? important,
  }) {
    return basic?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LowImportance value)? low,
    TResult Function(BasicImportance value)? basic,
    TResult Function(ImportantImportance value)? important,
    required TResult orElse(),
  }) {
    if (basic != null) {
      return basic(this);
    }
    return orElse();
  }
}

abstract class BasicImportance implements Importance {
  const factory BasicImportance() = _$BasicImportanceImpl;
}

/// @nodoc
abstract class _$$ImportantImportanceImplCopyWith<$Res> {
  factory _$$ImportantImportanceImplCopyWith(_$ImportantImportanceImpl value,
          $Res Function(_$ImportantImportanceImpl) then) =
      __$$ImportantImportanceImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ImportantImportanceImplCopyWithImpl<$Res>
    extends _$ImportanceCopyWithImpl<$Res, _$ImportantImportanceImpl>
    implements _$$ImportantImportanceImplCopyWith<$Res> {
  __$$ImportantImportanceImplCopyWithImpl(_$ImportantImportanceImpl _value,
      $Res Function(_$ImportantImportanceImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ImportantImportanceImpl implements ImportantImportance {
  const _$ImportantImportanceImpl();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ImportantImportanceImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() low,
    required TResult Function() basic,
    required TResult Function() important,
  }) {
    return important();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? low,
    TResult? Function()? basic,
    TResult? Function()? important,
  }) {
    return important?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? low,
    TResult Function()? basic,
    TResult Function()? important,
    required TResult orElse(),
  }) {
    if (important != null) {
      return important();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LowImportance value) low,
    required TResult Function(BasicImportance value) basic,
    required TResult Function(ImportantImportance value) important,
  }) {
    return important(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LowImportance value)? low,
    TResult? Function(BasicImportance value)? basic,
    TResult? Function(ImportantImportance value)? important,
  }) {
    return important?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LowImportance value)? low,
    TResult Function(BasicImportance value)? basic,
    TResult Function(ImportantImportance value)? important,
    required TResult orElse(),
  }) {
    if (important != null) {
      return important(this);
    }
    return orElse();
  }
}

abstract class ImportantImportance implements Importance {
  const factory ImportantImportance() = _$ImportantImportanceImpl;
}
